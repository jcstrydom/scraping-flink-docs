[
{"title": "Flink DataStream API Programming Guide#", "url": "https://nightlies.apache.org/flink/flink-docs-release-1.19/docs/dev/datastream/overview/", "version": "1.19", "crawl_run": "20250814_poc", "crawl_timestamp": "2025-08-14 19:04:07", "provenance": "nightlies.apache.org", "child_links": ["http://nightlies.apache.org/flink/flink-docs-release-1.19", "http://nightlies.apache.org/flink/flink-docs-release-1.18"], "markdown_content": "v1.19.3\n\n### On This Page\n\n# Flink DataStream API Programming Guide#\n\nDataStream programs in Flink are regular programs that implement transformations on data streams\n(e.g., filtering, updating state, defining windows, aggregating). The data streams are initially created from various\nsources (e.g., message queues, socket streams, files). Results are returned via sinks, which may for\nexample write the data to files, or to standard output (for example the command line\nterminal). Flink programs run in a variety of contexts, standalone, or embedded in other programs.\nThe execution can happen in a local JVM, or on clusters of many machines.\n\nIn order to create your own Flink DataStream program, we encourage you to start\nwithanatomy of a Flink Programand gradually\nadd your ownstream transformations. The remaining sections act as references for additional operations and advanced features.\n\n## What is a DataStream?#\n\nThe DataStream API gets its name from the specialDataStreamclass that is\nused to represent a collection of data in a Flink program. You can think of\nthem as immutable collections of data that can contain duplicates. This data\ncan either be finite or unbounded, the API that you use to work on them is the\nsame.\n\nADataStreamis similar to a regular JavaCollectionin terms of usage but\nis quite different in some key ways. They are immutable, meaning that once they\nare created you cannot add or remove elements. You can also not simply inspect\nthe elements inside but only work on them using theDataStreamAPI\noperations, which are also called transformations.\n\nYou can create an initialDataStreamby adding a source in a Flink program.\nThen you can derive new streams from this and combine them by using API methods\nsuch asmap,filter, and so on.\n\n## Anatomy of a Flink Program#\n\nFlink programs look like regular programs that transformDataStreams.  Each\nprogram consists of the same basic parts:\n\n> All Flink Scala APIs are deprecated and will be removed in a future Flink version. You can still build your application in Scala, but you should move to the Java version of either the DataStream and/or Table API.SeeFLIP-265 Deprecate and remove Scala API support\n\nAll Flink Scala APIs are deprecated and will be removed in a future Flink version. You can still build your application in Scala, but you should move to the Java version of either the DataStream and/or Table API.\n\nSeeFLIP-265 Deprecate and remove Scala API support\n\nWe will now give an overview of each of those steps, please refer to the\nrespective sections for more details. Note that all core classes of the Java\nDataStream API can be found inorg.apache.flink.streaming.api.\n\nTheStreamExecutionEnvironmentis the basis for all Flink programs. You can\nobtain one using these static methods onStreamExecutionEnvironment:\n\n```\n\ngetExecutionEnvironment();\n\ncreateLocalEnvironment();\n\ncreateRemoteEnvironment(String host, int port, String... jarFiles);\n\n\n```\n\nTypically, you only need to usegetExecutionEnvironment(), since this will do\nthe right thing depending on the context: if you are executing your program\ninside an IDE or as a regular Java program it will create a local environment\nthat will execute your program on your local machine. If you created a JAR file\nfrom your program, and invoke it through thecommand line, the Flink cluster manager will execute your main method andgetExecutionEnvironment()will return an execution environment for executing\nyour program on a cluster.\n\nFor specifying data sources the execution environment has several methods to\nread from files using various methods: you can just read them line by line, as\nCSV files, or using any of the other provided sources. To just read a text file\nas a sequence of lines, you can use:\n\n```\n\nfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\nDataStream<String> text = env.readTextFile(\"file:///path/to/file\");\n\n\n```\n\nThis will give you a DataStream on which you can then apply transformations to create new\nderived DataStreams.\n\nYou apply transformations by calling methods on DataStream with a\ntransformation functions. For example, a map transformation looks like this:\n\n```\n\nDataStream<String> input = ...;\n\nDataStream<Integer> parsed = input.map(new MapFunction<String, Integer>() {\n    @Override\n    public Integer map(String value) {\n        return Integer.parseInt(value);\n    }\n});\n\n\n```\n\nThis will create a new DataStream by converting every String in the original\ncollection to an Integer.\n\nOnce you have a DataStream containing your final results, you can write it to\nan outside system by creating a sink. These are just some example methods for\ncreating a sink:\n\n```\n\nwriteAsText(String path);\n\nprint();\n\n\n```\n\nWe will now give an overview of each of those steps, please refer to the\nrespective sections for more details. Note that all core classes of the Scala\nDataStream API can be found inorg.apache.flink.streaming.api.scala.\n\nTheStreamExecutionEnvironmentis the basis for all Flink programs. You can\nobtain one using these static methods onStreamExecutionEnvironment:\n\n```\n\ngetExecutionEnvironment()\n\ncreateLocalEnvironment()\n\ncreateRemoteEnvironment(host: String, port: Int, jarFiles: String*)\n\n\n```\n\nTypically, you only need to usegetExecutionEnvironment(), since this will do\nthe right thing depending on the context: if you are executing your program\ninside an IDE or as a regular Java program it will create a local environment\nthat will execute your program on your local machine. If you created a JAR file\nfrom your program, and invoke it through thecommand line, the Flink cluster manager will execute your main method andgetExecutionEnvironment()will return an execution environment for executing\nyour program on a cluster.\n\nFor specifying data sources the execution environment has several methods to\nread from files using various methods: you can just read them line by line, as\nCSV files, or using any of the other provided sources. To just read a text file\nas a sequence of lines, you can use:\n\n```\n\nval env = StreamExecutionEnvironment.getExecutionEnvironment()\n\nval text: DataStream[String] = env.readTextFile(\"file:///path/to/file\")\n\n\n```\n\nThis will give you a DataStream on which you can then apply transformations to\ncreate new derived DataStreams.\n\nYou apply transformations by calling methods on DataStream with a\ntransformation functions. For example, a map transformation looks like this:\n\n```\n\nval input: DataSet[String] = ...\n\nval mapped = input.map { x => x.toInt }\n\n\n```\n\nThis will create a new DataStream by converting every String in the original\ncollection to an Integer.\n\nOnce you have a DataStream containing your final results, you can write it to\nan outside system by creating a sink. These are just some example methods for\ncreating a sink:\n\n```\n\nwriteAsText(path: String)\n\nprint()\n\n\n```\n\nOnce you specified the complete program you need totrigger the program\nexecutionby callingexecute()on theStreamExecutionEnvironment.\nDepending on the type of theExecutionEnvironmentthe execution will be\ntriggered on your local machine or submit your program for execution on a\ncluster.\n\nTheexecute()method will wait for the job to finish and then return aJobExecutionResult, this contains execution times and accumulator results.\n\nIf you don\u2019t want to wait for the job to finish, you can trigger asynchronous\njob execution by callingexecuteAsync()on theStreamExecutionEnvironment.\nIt will return aJobClientwith which you can communicate with the job you\njust submitted. For instance, here is how to implement the semantics ofexecute()by usingexecuteAsync().\n\n```\n\nfinal JobClient jobClient = env.executeAsync();\n\nfinal JobExecutionResult jobExecutionResult = jobClient.getJobExecutionResult().get();\n\n\n```\n\nThat last part about program execution is crucial to understanding when and how\nFlink operations are executed. All Flink programs are executed lazily: When the\nprogram\u2019s main method is executed, the data loading and transformations do not\nhappen directly. Rather, each operation is created and added to a dataflow\ngraph. The operations are actually executed when the execution is explicitly\ntriggered by anexecute()call on the execution environment.  Whether the\nprogram is executed locally or on a cluster depends on the type of execution\nenvironment.\n\nThe lazy evaluation lets you construct sophisticated programs that Flink\nexecutes as one holistically planned unit.\n\nBack to top\n\n## Example Program#\n\nThe following program is a complete, working example of streaming window word count application, that counts the\nwords coming from a web socket in 5 second windows. You can copy & paste the code to run it locally.\n\n```\n\nimport org.apache.flink.api.common.functions.FlatMapFunction;\nimport org.apache.flink.api.java.tuple.Tuple2;\nimport org.apache.flink.streaming.api.datastream.DataStream;\nimport org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\nimport org.apache.flink.streaming.api.windowing.time.Time;\nimport org.apache.flink.util.Collector;\n\npublic class WindowWordCount {\n\n    public static void main(String[] args) throws Exception {\n\n        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\n\n        DataStream<Tuple2<String, Integer>> dataStream = env\n                .socketTextStream(\"localhost\", 9999)\n                .flatMap(new Splitter())\n                .keyBy(value -> value.f0)\n                .window(TumblingProcessingTimeWindows.of(Time.seconds(5)))\n                .sum(1);\n\n        dataStream.print();\n\n        env.execute(\"Window WordCount\");\n    }\n\n    public static class Splitter implements FlatMapFunction<String, Tuple2<String, Integer>> {\n        @Override\n        public void flatMap(String sentence, Collector<Tuple2<String, Integer>> out) throws Exception {\n            for (String word: sentence.split(\" \")) {\n                out.collect(new Tuple2<String, Integer>(word, 1));\n            }\n        }\n    }\n\n}\n\n\n```\n\n```\n\n\nimport org.apache.flink.streaming.api.scala._\nimport org.apache.flink.streaming.api.windowing.time.Time\n\nobject WindowWordCount {\n  def main(args: Array[String]) {\n\n    val env = StreamExecutionEnvironment.getExecutionEnvironment\n    val text = env.socketTextStream(\"localhost\", 9999)\n\n    val counts = text.flatMap { _.toLowerCase.split(\"\\\\W+\") filter { _.nonEmpty } }\n      .map { (_, 1) }\n      .keyBy(_._1)\n      .window(TumblingProcessingTimeWindows.of(Time.seconds(5)))\n      .sum(1)\n\n    counts.print()\n\n    env.execute(\"Window Stream WordCount\")\n  }\n}\n\n\n```\n\nTo run the example program, start the input stream with netcat first from a terminal:\n\n```\n\nnc -lk 9999\n\n\n```\n\nJust type some words hitting return for a new word. These will be the input to the\nword count program. If you want to see counts greater than 1, type the same word again and again within\n5 seconds (increase the window size from 5 seconds if you cannot type that fast \u263a).\n\nBack to top\n\n## Data Sources#\n\nSources are where your program reads its input from. You can attach a source to your program by\nusingStreamExecutionEnvironment.addSource(sourceFunction). Flink comes with a number of pre-implemented\nsource functions, but you can always write your own custom sources by implementing theSourceFunctionfor non-parallel sources, or by implementing theParallelSourceFunctioninterface or extending theRichParallelSourceFunctionfor parallel sources.\n\nThere are several predefined stream sources accessible from theStreamExecutionEnvironment:\n\nFile-based:\n\nreadTextFile(path)- Reads text files, i.e. files that respect theTextInputFormatspecification, line-by-line and returns them as Strings.\n\nreadFile(fileInputFormat, path)- Reads (once) files as dictated by the specified file input format.\n\nreadFile(fileInputFormat, path, watchType, interval, pathFilter, typeInfo)-  This is the method called internally by the two previous ones. It reads files in thepathbased on the givenfileInputFormat. Depending on the providedwatchType, this source may periodically monitor (everyintervalms) the path for new data (FileProcessingMode.PROCESS_CONTINUOUSLY), or process once the data currently in the path and exit (FileProcessingMode.PROCESS_ONCE). Using thepathFilter, the user can further exclude files from being processed.\n\nIMPLEMENTATION:\n\nUnder the hood, Flink splits the file reading process into two sub-tasks, namelydirectory monitoringanddata reading. Each of these sub-tasks is implemented by a separate entity. Monitoring is implemented by a single,non-parallel(parallelism = 1) task, while reading is performed by multiple tasks running in parallel. The parallelism of the latter is equal to the job parallelism. The role of the single monitoring task is to scan the directory (periodically or only once depending on thewatchType), find the files to be processed, divide them insplits, and assign these splits to the downstream readers. The readers are the ones who will read the actual data. Each split is read by only one reader, while a reader can read multiple splits, one-by-one.\n\nIMPORTANT NOTES:\n\nIf thewatchTypeis set toFileProcessingMode.PROCESS_CONTINUOUSLY, when a file is modified, its contents are re-processed entirely. This can break the \u201cexactly-once\u201d semantics, as appending data at the end of a file will lead toallits contents being re-processed.\n\nIf thewatchTypeis set toFileProcessingMode.PROCESS_ONCE, the source scans the pathonceand exits, without waiting for the readers to finish reading the file contents. Of course the readers will continue reading until all file contents are read. Closing the source leads to no more checkpoints after that point. This may lead to slower recovery after a node failure, as the job will resume reading from the last checkpoint.\n\nSocket-based:\n\nCollection-based:\n\nfromCollection(Collection)- Creates a data stream from the Java Java.util.Collection. All elements\nin the collection must be of the same type.\n\nfromCollection(Iterator, Class)- Creates a data stream from an iterator. The class specifies the\ndata type of the elements returned by the iterator.\n\nfromElements(T ...)- Creates a data stream from the given sequence of objects. All objects must be\nof the same type.\n\nfromParallelCollection(SplittableIterator, Class)- Creates a data stream from an iterator, in\nparallel. The class specifies the data type of the elements returned by the iterator.\n\nfromSequence(from, to)- Generates the sequence of numbers in the given interval, in\nparallel.\n\nCustom:\n\nSources are where your program reads its input from. You can attach a source to your program by\nusingStreamExecutionEnvironment.addSource(sourceFunction). Flink comes with a number of pre-implemented\nsource functions, but you can always write your own custom sources by implementing theSourceFunctionfor non-parallel sources, or by implementing theParallelSourceFunctioninterface or extending theRichParallelSourceFunctionfor parallel sources.\n\nThere are several predefined stream sources accessible from theStreamExecutionEnvironment:\n\nFile-based:\n\nreadTextFile(path)- Reads text files, i.e. files that respect theTextInputFormatspecification, line-by-line and returns them as Strings.\n\nreadFile(fileInputFormat, path)- Reads (once) files as dictated by the specified file input format.\n\nreadFile(fileInputFormat, path, watchType, interval, pathFilter)-  This is the method called internally by the two previous ones. It reads files in thepathbased on the givenfileInputFormat. Depending on the providedwatchType, this source may periodically monitor (everyintervalms) the path for new data (FileProcessingMode.PROCESS_CONTINUOUSLY), or process once the data currently in the path and exit (FileProcessingMode.PROCESS_ONCE). Using thepathFilter, the user can further exclude files from being processed.\n\nIMPLEMENTATION:\n\nUnder the hood, Flink splits the file reading process into two sub-tasks, namelydirectory monitoringanddata reading. Each of these sub-tasks is implemented by a separate entity. Monitoring is implemented by a single,non-parallel(parallelism = 1) task, while reading is performed by multiple tasks running in parallel. The parallelism of the latter is equal to the job parallelism. The role of the single monitoring task is to scan the directory (periodically or only once depending on thewatchType), find the files to be processed, divide them insplits, and assign these splits to the downstream readers. The readers are the ones who will read the actual data. Each split is read by only one reader, while a reader can read multiple splits, one-by-one.\n\nIMPORTANT NOTES:\n\nIf thewatchTypeis set toFileProcessingMode.PROCESS_CONTINUOUSLY, when a file is modified, its contents are re-processed entirely. This can break the \u201cexactly-once\u201d semantics, as appending data at the end of a file will lead toallits contents being re-processed.\n\nIf thewatchTypeis set toFileProcessingMode.PROCESS_ONCE, the source scans the pathonceand exits, without waiting for the readers to finish reading the file contents. Of course the readers will continue reading until all file contents are read. Closing the source leads to no more checkpoints after that point. This may lead to slower recovery after a node failure, as the job will resume reading from the last checkpoint.\n\nSocket-based:\n\nCollection-based:\n\nfromCollection(Seq)- Creates a data stream from the Java Java.util.Collection. All elements\nin the collection must be of the same type.\n\nfromCollection(Iterator)- Creates a data stream from an iterator. The class specifies the\ndata type of the elements returned by the iterator.\n\nfromElements(elements: _*)- Creates a data stream from the given sequence of objects. All objects must be\nof the same type.\n\nfromParallelCollection(SplittableIterator)- Creates a data stream from an iterator, in\nparallel. The class specifies the data type of the elements returned by the iterator.\n\nfromSequence(from, to)- Generates the sequence of numbers in the given interval, in\nparallel.\n\nCustom:\n\nBack to top\n\n## DataStream Transformations#\n\nPlease seeoperatorsfor an overview of the available stream transformations.\n\nBack to top\n\n## Data Sinks#\n\nData sinks consume DataStreams and forward them to files, sockets, external systems, or print them.\nFlink comes with a variety of built-in output formats that are encapsulated behind operations on the\nDataStreams:\n\nwriteAsText()/TextOutputFormat- Writes elements line-wise as Strings. The Strings are\nobtained by calling thetoString()method of each element.\n\nwriteAsCsv(...)/CsvOutputFormat- Writes tuples as comma-separated value files. Row and field\ndelimiters are configurable. The value for each field comes from thetoString()method of the objects.\n\nprint()/printToErr()- Prints thetoString()value\nof each element on the standard out / standard error stream. Optionally, a prefix (msg) can be provided which is\nprepended to the output. This can help to distinguish between different calls toprint. If the parallelism is\ngreater than 1, the output will also be prepended with the identifier of the task which produced the output.\n\nwriteUsingOutputFormat()/FileOutputFormat- Method and base class for custom file outputs. Supports\ncustom object-to-bytes conversion.\n\nwriteToSocket- Writes elements to a socket according to aSerializationSchema\n\naddSink- Invokes a custom sink function. Flink comes bundled with connectors to other systems (such as\nApache Kafka) that are implemented as sink functions.\n\nData sinks consume DataStreams and forward them to files, sockets, external systems, or print them.\nFlink comes with a variety of built-in output formats that are encapsulated behind operations on the\nDataStreams:\n\nwriteAsText()/TextOutputFormat- Writes elements line-wise as Strings. The Strings are\nobtained by calling thetoString()method of each element.\n\nwriteAsCsv(...)/CsvOutputFormat- Writes tuples as comma-separated value files. Row and field\ndelimiters are configurable. The value for each field comes from thetoString()method of the objects.\n\nprint()/printToErr()- Prints thetoString()value\nof each element on the standard out / standard error stream. Optionally, a prefix (msg) can be provided which is\nprepended to the output. This can help to distinguish between different calls toprint. If the parallelism is\ngreater than 1, the output will also be prepended with the identifier of the task which produced the output.\n\nwriteUsingOutputFormat()/FileOutputFormat- Method and base class for custom file outputs. Supports\ncustom object-to-bytes conversion.\n\nwriteToSocket- Writes elements to a socket according to aSerializationSchema\n\naddSink- Invokes a custom sink function. Flink comes bundled with connectors to other systems (such as\nApache Kafka) that are implemented as sink functions.\n\nNote that thewrite*()methods onDataStreamare mainly intended for debugging purposes.\nThey are not participating in Flink\u2019s checkpointing, this means these functions usually have\nat-least-once semantics. The data flushing to the target system depends on the implementation of the\nOutputFormat. This means that not all elements send to the OutputFormat are immediately showing up\nin the target system. Also, in failure cases, those records might be lost.\n\nFor reliable, exactly-once delivery of a stream into a file system, use theFileSink.\nAlso, custom implementations through the.addSink(...)method can participate in Flink\u2019s checkpointing\nfor exactly-once semantics.\n\nBack to top\n\n## Execution Parameters#\n\nTheStreamExecutionEnvironmentcontains theExecutionConfigwhich allows to set job specific configuration values for the runtime.\n\nPlease refer toexecution configurationfor an explanation of most parameters. These parameters pertain specifically to the DataStream API:\n\nBack to top\n\n### Fault Tolerance#\n\nState & Checkpointingdescribes how to enable and configure Flink\u2019s checkpointing mechanism.\n\n### Controlling Latency#\n\nBy default, elements are not transferred on the network one-by-one (which would cause unnecessary network traffic)\nbut are buffered. The size of the buffers (which are actually transferred between machines) can be set in the Flink config files.\nWhile this method is good for optimizing throughput, it can cause latency issues when the incoming stream is not fast enough.\nTo control throughput and latency, you can useenv.setBufferTimeout(timeoutMillis)on the execution environment\n(or on individual operators) to set a maximum wait time for the buffers to fill up. After this time, the\nbuffers are sent automatically even if they are not full. The default value for this timeout is 100 ms.\n\nUsage:\n\n```\n\nLocalStreamEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();\nenv.setBufferTimeout(timeoutMillis);\n\nenv.generateSequence(1,10).map(new MyMapper()).setBufferTimeout(timeoutMillis);\n\n\n```\n\n```\n\nval env: LocalStreamEnvironment = StreamExecutionEnvironment.createLocalEnvironment\nenv.setBufferTimeout(timeoutMillis)\n\nenv.generateSequence(1,10).map(myMap).setBufferTimeout(timeoutMillis)\n\n\n```\n\nTo maximize throughput, setsetBufferTimeout(-1)which will remove the timeout and buffers will only be\nflushed when they are full. To minimize latency, set the timeout to a value close to 0 (for example 5 or 10 ms).\nA buffer timeout of 0 should be avoided, because it can cause severe performance degradation.\n\nBack to top\n\n## Debugging#\n\nBefore running a streaming program in a distributed cluster, it is a good\nidea to make sure that the implemented algorithm works as desired. Hence, implementing data analysis\nprograms is usually an incremental process of checking results, debugging, and improving.\n\nFlink provides features to significantly ease the development process of data analysis\nprograms by supporting local debugging from within an IDE, injection of test data, and collection of\nresult data. This section give some hints how to ease the development of Flink programs.\n\n### Local Execution Environment#\n\nALocalStreamEnvironmentstarts a Flink system within the same JVM process it was created in. If you\nstart the LocalEnvironment from an IDE, you can set breakpoints in your code and easily debug your\nprogram.\n\nA LocalEnvironment is created and used as follows:\n\n```\n\nfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();\n\nDataStream<String> lines = env.addSource(/* some source */);\n// build your program\n\nenv.execute();\n\n\n```\n\n```\n\nval env = StreamExecutionEnvironment.createLocalEnvironment()\n\nval lines = env.addSource(/* some source */)\n// build your program\n\nenv.execute()\n\n\n```\n\n### Collection Data Sources#\n\nFlink provides special data sources which are backed\nby Java collections to ease testing. Once a program has been tested, the sources and sinks can be\neasily replaced by sources and sinks that read from / write to external systems.\n\nCollection data sources can be used as follows:\n\n```\n\nfinal StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment();\n\n// Create a DataStream from a list of elements\nDataStream<Integer> myInts = env.fromElements(1, 2, 3, 4, 5);\n\n// Create a DataStream from any Java collection\nList<Tuple2<String, Integer>> data = ...\nDataStream<Tuple2<String, Integer>> myTuples = env.fromCollection(data);\n\n// Create a DataStream from an Iterator\nIterator<Long> longIt = ...;\nDataStream<Long> myLongs = env.fromCollection(longIt, Long.class);\n\n\n```\n\n```\n\nval env = StreamExecutionEnvironment.createLocalEnvironment()\n\n// Create a DataStream from a list of elements\nval myInts = env.fromElements(1, 2, 3, 4, 5)\n\n// Create a DataStream from any Collection\nval data: Seq[(String, Int)] = ...\nval myTuples = env.fromCollection(data)\n\n// Create a DataStream from an Iterator\nval longIt: Iterator[Long] = ...\nval myLongs = env.fromCollection(longIt)\n\n\n```\n\nNote:Currently, the collection data source requires that data types and iterators implementSerializable. Furthermore, collection data sources can not be executed in parallel (\nparallelism = 1).\n\n### Iterator Data Sink#\n\nFlink also provides a sink to collect DataStream results for testing and debugging purposes. It can be used as follows:\n\n```\n\nDataStream<Tuple2<String, Integer>> myResult = ...;\nIterator<Tuple2<String, Integer>> myOutput = myResult.collectAsync();\n\n\n```\n\n```\n\nval myResult: DataStream[(String, Int)] = ...\nval myOutput: Iterator[(String, Int)] = myResult.collectAsync()\n\n\n```\n\n## Where to go next?#\n\nBack to top\n\n### On This Page"},
{"title": "Untitled", "url": "https://nightlies.apache.org/flink/flink-docs-stable/docs/dev/table/", "version": "2.1", "crawl_run": "20250814_poc", "crawl_timestamp": "2025-08-14 19:04:07", "provenance": "nightlies.apache.org", "child_links": ["http://nightlies.apache.org/flink/flink-docs-release-2.1", "http://nightlies.apache.org/flink/flink-docs-release-2.0"], "markdown_content": "v2.1.0\n\n### On This Page\n\n### On This Page"}
]